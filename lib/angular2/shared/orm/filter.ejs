/* tslint:disable */
import 'rxjs/add/operator/publishReplay';
import 'rxjs/add/operator/combineLatest';
import 'rxjs/add/operator/withLatestFrom';
import { Observable } from 'rxjs/Observable';
import * as filterNodes from 'loopback-filters';

import * as models from '../models';

import { LoopBackFilter } from '../models';

export function applyFilter(state$: Observable<any>, filter: LoopBackFilter, store: any, model: any): Observable<any> {
  return include(
    state$
      .map((state: any) => {
        if (Array.isArray(state)) {
          return state;
        }

        return state ? [state]: [];
      })
      .map((data: any | any[]) => filterNodes(data, filter))
      .publishReplay(1).refCount()
    , filter, store, model);
}

function include(state$: Observable<any>, filter: LoopBackFilter, store: any, model: any): Observable<any> {
  if (!filter.include) {
    return state$;
  }

  const normalizedInclude = normalizeInclude(filter.include);

  const stateEntities$ = state$.map((data) => {
    const entities: any = {};

    for (const include of normalizedInclude) {
      let relationSchema: any;
      if (isPlainObject(include)) {
        relationSchema = model.getModelDefinition().relations[include.relation];
      } else {
        relationSchema = model.getModelDefinition().relations[include];
      }
    }

    for (const item of data) {
      entities[item[model.getModelDefinition().idName]] = item;
    }

    return entities;
  })
  .publishReplay(1).refCount();

  const includesArray: any[] = [];

  for (const include of normalizedInclude) {
    let relationSchema: any;
    if (isPlainObject(include)) {
      relationSchema = model.getModelDefinition().relations[include.relation];
    } else {
      relationSchema = model.getModelDefinition().relations[include];
    }

    if (!!relationSchema.model) {
      if (relationSchema.modelThrough) {
        /*includesArray.push(
          applyFilter(
            store.select(relationSchema.model + 's')
              .map((state: any) => state.entities)
              .combineLatest(store.select(relationSchema.modelThrough + 's'),
                (includeState: any, thoughState: any) => ({includeState, thoughState}))
              .withLatestFrom(stateEntities$,
                ({includeState, thoughState}, stateEntities: any) => ({includeState, thoughState, stateEntities}))
              .map(({includeState, thoughState, stateEntities}) => {
                let data: any | any[];
                console.log(includeState, thoughState, stateEntities);
                // TODO
                return data;
              })
              .map((data: any | any[]) => {
                if (!data || !Array.isArray(data) || !include.scope) {
                  return data;
                }

                return filterNodes(data, include.scope)
              })
              .publishReplay(1).refCount()
          , include.scope || include, store, models[relationSchema.model])
        );*/
      } else {
        includesArray.push(
          applyFilter(
            store.select(relationSchema.model + 's')
              .map((state: any) => state.entities)
              .withLatestFrom(stateEntities$,
                (includeState: any, stateEntities: any) => ({includeState, stateEntities}))
              .auditTime(0)
              .map(({includeState, stateEntities}) => {
                let data: any | any[];

                if (!Object.keys(stateEntities).length) {
                  return data;
                }

                if (relationSchema.relationType === 'belongsTo') {
                  for (const key in stateEntities) {
                    if (stateEntities.hasOwnProperty(key) &&
                      includeState.hasOwnProperty(stateEntities[key][relationSchema.keyFrom])) {
                      data = Object.assign({}, includeState[stateEntities[key][relationSchema.keyFrom]], {
                        relationParentId: key
                      });
                    }
                  }
                } else if (relationSchema.relationType === 'hasOne') {
                  for (const key in includeState) {
                    if (includeState.hasOwnProperty(key) &&
                      stateEntities.hasOwnProperty(includeState[key][relationSchema.keyTo])) {
                      data = includeState[key];
                    }
                  }
                } else {
                  data = [];

                  for (const key in includeState) {
                    if (includeState.hasOwnProperty(key) &&
                      stateEntities.hasOwnProperty(includeState[key][relationSchema.keyTo])) {
                      data.push(includeState[key]);
                    }
                  }
                }

                return data;
              })
              .map((data: any | any[]) => {
                if (!data || !Array.isArray(data) || !include.scope) {
                  return data;
                }

                return filterNodes(data, include.scope)
              })
              .publishReplay(1).refCount()
          , include.scope || include, store, models[relationSchema.model])
        );
      }
    }
  }

  return stateEntities$
    .combineLatest(...includesArray, (...args) => args)
    .auditTime(0)
    .map((args) => {
      const stateEntities: any = JSON.parse(JSON.stringify(args[0]));
      const data: any[] = [];

      for (let i = 1; i < args.length; ++i) {
        for (const item of args[i]) {
          const includeString: string = normalizedInclude[i - 1].relation || normalizedInclude[i - 1];
          const relationSchema = model.getModelDefinition().relations[includeString];

          if (relationSchema.relationType === 'belongsTo') {
            for (const key in stateEntities) {
              if (stateEntities.hasOwnProperty(key) && item.relationParentId === key) {
                stateEntities[key][includeString] = item;
              }
            }
          } else {
            if (stateEntities.hasOwnProperty(item[relationSchema.keyTo])) {
              if (relationSchema.relationType === 'hasOne') {
                stateEntities[item[relationSchema.keyTo]][includeString] = item;
              } else {
                if (typeof stateEntities[item[relationSchema.keyTo]][includeString] === 'undefined') {
                  stateEntities[item[relationSchema.keyTo]][includeString] =
                    relationSchema.type.indexOf('[]') !== -1 ? [] : null
                }

                stateEntities[item[relationSchema.keyTo]][includeString] = [
                  ...stateEntities[item[relationSchema.keyTo]][includeString],
                  item
                ];
              }
            }
          }
        }
      }

      for (let key in stateEntities) {
        if (stateEntities.hasOwnProperty(key)) {
          data.push(stateEntities[key]);
        }
      }

      return data;
    })
    .auditTime(0)
    .publishReplay(1).refCount();
}

/*!
 * Normalize the include to be an array
 * @param include
 * @returns {*}
 */
function normalizeInclude(include) {
  let newInclude;
  if (typeof include === 'string') {
    return [include];
  } else if (isPlainObject(include)) {
    return [include];
  } else if (Array.isArray(include)) {
    newInclude = [];
    let i: number;
    let n: number;
    for (i = 0, n = include.length; i < n; i++) {
      const subIncludes = normalizeInclude(include[i]);
      newInclude = newInclude.concat(subIncludes);
    }
    return newInclude;
  } else {
    return include;
  }
}

function isPlainObject(obj: any): boolean {
  return (typeof obj === 'object') && (obj !== null) &&
    (obj.constructor === Object);
}

export function toArray(state: any): any[] {
  const entities = [];
  
  for (let key in state.entities) {
    if (state.entities.hasOwnProperty(key)) {
      entities.push(state.entities[key]);
    }
  }

  return entities;
}

export function filterById(state: any[], id: any, relation: string, model: any): any[] {
  if (model.getModelDefinition().relations[relation].modelThrough) {
    return state
      .filter((item: any) => item[model.getModelDefinition().relations[relation].modelThrough] &&
        item[model.getModelDefinition().relations[relation].modelThrough][model.getModelDefinition().relations[relation].keyTo] === id);
  } else {
    return state.filter((item: any) => item[model.getModelDefinition().relations[relation].keyTo] === id);
  }
}
